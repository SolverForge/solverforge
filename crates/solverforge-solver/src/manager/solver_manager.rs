//! SolverManager for async job management.
//!
//! Provides the high-level API for:
//! - Starting/stopping solve jobs with callbacks
//! - Tracking solver status per job
//! - Early termination of solving jobs
//!
//! This follows Timefold's `SolverManager` pattern - async job orchestration
//! without knowledge of constraint internals.

use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, Mutex};
use std::thread::JoinHandle;

use solverforge_core::score::Score;

use crate::basic::SolverEvent;

/// Trait for solutions that can be solved with events.
///
/// This trait is implemented by the `#[planning_solution]` macro when
/// `constraints` is specified. It allows `SolverManager` to call
/// `solve_with_events` without knowing the concrete solution type.
///
/// # Type Parameters
///
/// The solution must be `Clone + Send + 'static` to support async job execution.
///
/// # Example
///
/// ```ignore
/// // Generated by #[planning_solution]
/// impl Solvable for Schedule {
///     fn solve_with_events<E, F>(
///         self,
///         terminate: Option<&AtomicBool>,
///         on_event: E,
///         on_best_solution: F,
///     ) -> Self
///     where
///         E: FnMut(SolverEvent<HardSoftScore>),
///         F: FnMut(&Self, HardSoftScore),
///     {
///         // calls run_solver_with_events internally
///     }
/// }
/// ```
pub trait Solvable: solverforge_core::domain::PlanningSolution + Clone + Send + 'static {
    /// Solves the solution with event callbacks and optional termination.
    ///
    /// # Arguments
    ///
    /// * `terminate` - Optional flag to request early termination (zero-cost reference)
    /// * `on_event` - Callback for solver events (phases, steps, etc.)
    /// * `on_best_solution` - Callback when a new best solution is found
    fn solve_with_events<E, F>(
        self,
        terminate: Option<&AtomicBool>,
        on_event: E,
        on_best_solution: F,
    ) -> Self
    where
        E: FnMut(SolverEvent<Self::Score>),
        F: FnMut(&Self, Self::Score);
}

/// Status of a solving job.
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum SolverStatus {
    /// Not currently solving.
    NotSolving,
    /// Actively solving.
    Solving,
}

impl SolverStatus {
    /// Returns the status as a string.
    pub fn as_str(self) -> &'static str {
        match self {
            SolverStatus::NotSolving => "NOT_SOLVING",
            SolverStatus::Solving => "SOLVING",
        }
    }
}

/// Internal job state.
struct SolveJob<S> {
    status: SolverStatus,
    solution: S,
    terminate_flag: Arc<AtomicBool>,
    #[allow(dead_code)]
    handle: Option<JoinHandle<()>>,
}

/// Manages async solve jobs with callbacks for best solution updates.
///
/// This is the Rust equivalent of Timefold's `SolverManager`. It provides
/// job management for concurrent solving with termination support.
///
/// # Type Parameters
///
/// * `S` - Solution type that implements `Solvable`
///
/// # Thread Safety
///
/// `SolverManager` is thread-safe. Jobs can be started, queried, and terminated
/// from any thread.
pub struct SolverManager<S: Solvable> {
    jobs: Mutex<HashMap<String, SolveJob<S>>>,
}

impl<S: Solvable> Default for SolverManager<S> {
    fn default() -> Self {
        Self::new()
    }
}

impl<S: Solvable> SolverManager<S>
where
    S::Score: Score,
{
    /// Creates a new SolverManager.
    pub fn new() -> Self {
        Self {
            jobs: Mutex::new(HashMap::new()),
        }
    }

    /// Starts solving a problem and calls the listener with each best solution.
    ///
    /// This is the main API matching Timefold's `solveAndListen`.
    /// It calls `solve_with_events` internally - no manual wiring needed.
    ///
    /// # Arguments
    ///
    /// * `problem_id` - Unique identifier for this job
    /// * `initial_solution` - The starting solution
    /// * `listener` - Callback invoked with each new best solution
    pub fn solve_and_listen<L>(
        &self,
        problem_id: impl Into<String>,
        initial_solution: S,
        listener: L,
    ) where
        L: Fn(&S) + Send + 'static,
    {
        let problem_id = problem_id.into();
        let terminate_flag = Arc::new(AtomicBool::new(false));

        // Create job entry
        {
            let mut jobs = self.jobs.lock().unwrap();
            jobs.insert(
                problem_id.clone(),
                SolveJob {
                    status: SolverStatus::Solving,
                    solution: initial_solution.clone(),
                    terminate_flag: terminate_flag.clone(),
                    handle: None,
                },
            );
        }

        // Clone flag for the thread - we need owned data
        let terminate_for_thread = terminate_flag.clone();

        // Spawn solving thread
        let handle = std::thread::spawn(move || {
            // Call solve_with_events - the macro-generated method
            // We need to leak the Arc to get a &'static AtomicBool for the thread
            // This is safe because the thread owns the Arc
            let flag_ref: &AtomicBool = unsafe {
                // SAFETY: The Arc keeps the AtomicBool alive for the duration of solving.
                // The thread owns a clone of the Arc, so the data won't be dropped.
                &*Arc::as_ptr(&terminate_for_thread)
            };

            let result = initial_solution.solve_with_events(
                Some(flag_ref),
                |_event| {
                    // Events can be logged/handled here if needed
                },
                |best_solution, _score| {
                    // Call listener with each new best solution
                    listener(best_solution);
                },
            );

            // Final callback with result
            listener(&result);
        });

        // Update job with handle
        {
            let mut jobs = self.jobs.lock().unwrap();
            if let Some(job) = jobs.get_mut(&problem_id) {
                job.handle = Some(handle);
            }
        }
    }

    /// Gets the solver status for a job.
    pub fn get_solver_status(&self, problem_id: &str) -> SolverStatus {
        let jobs = self.jobs.lock().unwrap();
        jobs.get(problem_id)
            .map(|job| job.status)
            .unwrap_or(SolverStatus::NotSolving)
    }

    /// Gets the current best solution for a job.
    pub fn get_solution(&self, problem_id: &str) -> Option<S> {
        let jobs = self.jobs.lock().unwrap();
        jobs.get(problem_id).map(|job| job.solution.clone())
    }

    /// Updates the solution for a job (called from listener callback).
    pub fn update_solution(&self, problem_id: &str, solution: S) {
        let mut jobs = self.jobs.lock().unwrap();
        if let Some(job) = jobs.get_mut(problem_id) {
            job.solution = solution;
        }
    }

    /// Marks a job as finished.
    pub fn mark_finished(&self, problem_id: &str) {
        let mut jobs = self.jobs.lock().unwrap();
        if let Some(job) = jobs.get_mut(problem_id) {
            job.status = SolverStatus::NotSolving;
        }
    }

    /// Requests early termination of a job.
    ///
    /// Returns `true` if the job was found and termination was requested.
    pub fn terminate_early(&self, problem_id: &str) -> bool {
        let jobs = self.jobs.lock().unwrap();
        if let Some(job) = jobs.get(problem_id) {
            job.terminate_flag.store(true, Ordering::SeqCst);
            true
        } else {
            false
        }
    }

    /// Removes a job from the manager.
    pub fn remove_job(&self, problem_id: &str) -> Option<S> {
        let mut jobs = self.jobs.lock().unwrap();
        jobs.remove(problem_id).map(|job| job.solution)
    }

    /// Lists all job IDs.
    pub fn list_jobs(&self) -> Vec<String> {
        let jobs = self.jobs.lock().unwrap();
        jobs.keys().cloned().collect()
    }
}
