# Zoyd Progress Log

## Iteration 1 - 2026-02-04 21:42:29

Task completed. I added the `id_to_location: HashMap<i64, (usize, usize)>` field to the `DynamicSolution` struct in `crates/solverforge-dynamic/src/solution.rs`. 

Summary of changes:
1. Added `use std::collections::HashMap;` import
2. Added the `pub id_to_location: HashMap<i64, (usize, usize)>` field to `DynamicSolution` with documentation
3. Updated the `new()` constructor to initialize `id_to_location: HashMap::new()`
4. Updated 11 other files that construct `DynamicSolution` via struct literal syntax to include the new field

All 28 tests in the solverforge-dynamic crate pass.


## Iteration 2 - 2026-02-04 21:45:40

Task completed. I implemented the HashMap<i64, (usize, usize)> for id_to_location lookup by:

1. **Updated `add_entity`** (solution.rs:277-285): Now inserts entity ID into `id_to_location` map before pushing to the entities vector, storing `(class_idx, entity_idx)`.

2. **Added `get_entity_location`** method (solution.rs:287-291): Returns `Option<(usize, usize)>` for O(1) entity location lookup by ID.

3. **Added test** `test_id_to_location_lookup`: Verifies the lookup works correctly across multiple entity classes with different IDs, and confirms non-existent IDs return `None`.

All 29 tests pass. The infrastructure is now in place for the next tasks to refactor `make_bi_filter`, `make_tri_filter`, and `make_cross_filter` to use this O(1) lookup instead of the current O(n) `iter().position()` calls.


## Iteration 3 - 2026-02-04 21:47:18

Task completed. I refactored `make_bi_filter` in `crates/solverforge-dynamic/src/constraint/closures_bi.rs` to use the O(1) `id_to_location` HashMap lookup instead of the O(n) `iter().position()` calls.

**Summary of changes:**
- Replaced the O(n) `entities.iter().position(|e| e.id == a.id)` lookups (lines 47-48) with O(1) `solution.get_entity_location(a.id)` HashMap lookups
- Added verification that the entities are from the expected `class_idx` (defensive check)
- Updated the docstring to reflect the O(1) performance improvement
- All 29 tests pass and clippy reports no warnings


## Iteration 4 - 2026-02-04 21:48:52

Task completed. I refactored `make_tri_filter` in `crates/solverforge-dynamic/src/constraint/closures_tri.rs` to use the O(1) `id_to_location` HashMap lookup instead of the O(n) `iter().position()` calls.

**Summary of changes:**
- Replaced the O(n) `entities.iter().position(|e| e.id == a.id)` lookups (lines 43-45) with O(1) `solution.get_entity_location(a.id)` HashMap lookups for all three entities (a, b, c)
- Added verification that all three entities are from the expected `class_idx` (defensive check)
- Updated the docstring to reflect the O(1) performance improvement
- All 29 tests pass and clippy reports no warnings


## Iteration 5 - 2026-02-04 21:52:22

Task completed. Here's a summary of the changes:

**Refactored `make_cross_filter` in `closures_cross.rs`:**
- Replaced O(n) `iter().position()` lookups (lines 171-172) with O(1) `solution.get_entity_location()` HashMap lookups
- Added verification that entities come from their expected classes (`class_idx_a` and `class_idx_b`)
- Updated the docstring to reflect the O(1) performance improvement

**Fixed tests in `constraint/tests.rs`:**
- Updated `test_cross_bi_constraint` to use globally unique entity IDs across classes (employees: 100-102, shifts: 200-203)
- Updated `test_incremental_delta_matches_full_recalculation` Test 3 (Cross-Bi) to use unique IDs (employees: 100-101, shifts: 200-202)
- This was necessary because the `id_to_location` HashMap requires globally unique entity IDs, matching the real-world behavior where Python's `Solver.next_entity_id` assigns sequential IDs across all classes

All 29 tests pass and clippy reports no warnings.


## Iteration 6 - 2026-02-04 21:55:01

I've completed the task. Let me provide a summary of the changes made:

## Summary

I completed the task "Change DynBiWeight signature to accept solution reference and indices" by making the following changes:

### 1. Updated `types.rs` (line 53-58)
Changed the `DynBiWeight` type alias from:
```rust
pub type DynBiWeight = Box<dyn Fn(&DynamicEntity, &DynamicEntity) -> HardSoftScore + Send + Sync>;
```
to:
```rust
pub type DynBiWeight =
    Box<dyn Fn(&DynamicSolution, usize, usize) -> HardSoftScore + Send + Sync>;
```

### 2. Updated `closures_bi.rs` (lines 67-124)
Refactored `make_bi_weight` function to:
- Accept solution reference and entity indices instead of entity references
- Eliminate temporary solution construction and entity cloning
- Use actual indices from the solution for evaluation context
- Updated docstring to reflect the new behavior and performance benefits

### Build Status
The build is **expected to fail** until the next task is completed:
- "Update IncrementalBiConstraint to pass solution to weight function (nary_incremental.rs)"

This is because `IncrementalBiConstraint` in solverforge-scoring still expects `W: Fn(&A, &A) -> Sc`, but the new `DynBiWeight` signature is `Fn(&DynamicSolution, usize, usize) -> HardSoftScore`. The subsequent task will update `IncrementalBiConstraint` to match the new signature.


## Iteration 7 - 2026-02-04 22:02:02

I've completed the task. Here's a summary of the changes made:

## Summary

Updated `IncrementalBiConstraint` in `nary_incremental.rs` to pass solution reference and indices to the weight function instead of entity references.

### Changes Made:

1. **`nary_incremental.rs`** (solverforge-scoring):
   - Changed weight type bound from `W: Fn(&A, &A) -> Sc` to `W: Fn(&S, usize, usize) -> Sc`
   - Updated `compute_score` method signature from `(&self, a: &A, b: &A)` to `(&self, solution: &S, a_idx: usize, b_idx: usize)`
   - Updated `retract_entity` method to accept `solution: &S` parameter
   - Updated all call sites to pass solution and indices instead of entity references

2. **`arity_stream_macros.rs`** (solverforge-scoring):
   - Added extractor cloning (`E: Clone`) to adapt user's `Fn(&A, &A) -> Sc` closures to the new internal signature `Fn(&S, usize, usize) -> Sc`
   - The `as_constraint` method now creates an adapter that extracts entities from the solution using indices before calling the user's weight function

3. **`macros.rs`** (solverforge-scoring):
   - Updated `impl_get_matches_nary!` bi-constraint macro to pass `($solution, idx_a, idx_b)` instead of `(a, b)`

4. **`bi_incr_tests.rs`** (solverforge-scoring):
   - Updated all 10 test cases to use the new weight function signature `|_s: &NQueensSolution, _a_idx: usize, _b_idx: usize|`

5. **`typed_bench.rs`** (solverforge-scoring):
   - Updated 2 occurrences of `IncrementalBiConstraint::new()` to use the new weight signature

### Test Results:
- All 29 solverforge-dynamic tests pass
- All 73 solverforge-scoring doc tests pass
- All workspace tests pass
- No clippy warnings


## Iteration 8 - 2026-02-04 22:03:44

I've completed the task. Here's a summary:

## Summary

Changed the `DynTriWeight` type alias in `crates/solverforge-dynamic/src/constraint/types.rs` to accept a solution reference and three entity indices instead of three entity references.

### Change Made

**Before:**
```rust
/// Tri-constraint weight: computes score for triple.
pub type DynTriWeight =
    Box<dyn Fn(&DynamicEntity, &DynamicEntity, &DynamicEntity) -> HardSoftScore + Send + Sync>;
```

**After:**
```rust
/// Tri-constraint weight: computes score for triple using solution reference and entity indices.
///
/// Takes the full solution and three indices into the entity slice, avoiding entity cloning.
/// The indices are positions within `solution.entities[class_idx]`.
pub type DynTriWeight =
    Box<dyn Fn(&DynamicSolution, usize, usize, usize) -> HardSoftScore + Send + Sync>;
```

### Build Status

The build is **expected to fail** until subsequent tasks are completed:
- "Refactor make_tri_weight to use indices instead of cloning" (next task)
- Update `IncrementalTriConstraint` to match the new signature (future task, similar to what was done for bi-constraints)

The compilation errors confirm the signature change is in place and awaiting the follow-up tasks to update the closure in `closures_tri.rs` and the constraint implementation in `nary_incremental.rs`.


## Iteration 9 - 2026-02-04 22:10:56

Task complete. Here's a summary of the changes made:

## Summary

Refactored `make_tri_weight` in `closures_tri.rs` to use indices instead of cloning entities. This required updating the `IncrementalTriConstraint` implementation across multiple files.

### Changes Made:

1. **`closures_tri.rs`** (solverforge-dynamic): Updated `make_tri_weight` function to:
   - Accept solution reference and three entity indices instead of entity references
   - Eliminate temporary solution construction and entity cloning
   - Use actual indices from the solution for evaluation context

2. **`nary_incremental.rs`** (solverforge-scoring): Updated `IncrementalTriConstraint` macro:
   - Changed weight type bound from `W: Fn(&A, &A, &A) -> Sc` to `W: Fn(&S, usize, usize, usize) -> Sc`
   - Updated `compute_score` to accept `solution: &S, a_idx, b_idx, c_idx`
   - Updated `insert_entity` weight call to use `weight(solution, a_idx, b_idx, c_idx)`
   - Updated `retract_entity` to accept `solution: &S` parameter and updated `compute_score` calls
   - Updated trait impl bounds to match

3. **`macros.rs`** (solverforge-scoring): Updated tri-constraint `get_matches` macro to call `compute_score($solution, i, j, k)` instead of `compute_score(a, b, c)`

4. **`arity_stream_macros.rs`** (solverforge-scoring): Updated tri-constraint `as_constraint` method to:
   - Require `E: Clone` bound on extractor
   - Create an adapter that converts user's `Fn(&A, &A, &A) -> Sc` to internal `Fn(&S, usize, usize, usize) -> Sc`

5. **`tri_incr_tests.rs`** (solverforge-scoring): Updated 4 test cases to use the new weight signature

### Test Results:
- All 29 solverforge-dynamic tests pass
- All 104 solverforge-scoring unit tests pass
- All 73 solverforge-scoring doctests pass
- No clippy warnings


## Iteration 10 - 2026-02-04 22:11:59

Task complete. I changed the `DynCrossWeight` type alias in `types.rs` from:

```rust
pub type DynCrossWeight =
    Box<dyn Fn(&DynamicEntity, &DynamicEntity) -> HardSoftScore + Send + Sync>;
```

to:

```rust
pub type DynCrossWeight =
    Box<dyn Fn(&DynamicSolution, usize, usize) -> HardSoftScore + Send + Sync>;
```

The new signature accepts a solution reference and two entity indices (one for each class in the cross-join), matching the pattern established for `DynBiWeight` and `DynTriWeight`. This enables eliminating entity cloning in the weight function.

The build currently fails as expected because `make_cross_weight` in `closures_cross.rs` and `IncrementalCrossBiConstraint` in `cross_bi_incremental.rs` still use the old signature. These will be addressed by the subsequent tasks in the PRD.


## Iteration 11 - 2026-02-04 22:16:17

Task completed. Here's a summary of the changes made:

## Summary

I refactored `make_cross_weight` in `closures_cross.rs` to use the solution reference instead of cloning entities. This required changes across multiple files:

### 1. `closures_cross.rs` (solverforge-dynamic)
- Changed `make_cross_weight` signature to accept `(&DynamicSolution, usize, usize)` instead of `(&DynamicEntity, &DynamicEntity)`
- Removed the `descriptor` parameter since it's no longer needed
- Eliminated temporary solution construction and entity cloning
- Now uses actual solution and entity indices for evaluation context

### 2. `cross_bi_incremental.rs` (solverforge-scoring)
- Changed weight type bound from `W: Fn(&A, &B) -> Sc` to `W: Fn(&S, usize, usize) -> Sc`
- Updated `compute_score` method to accept `solution: &S, a_idx: usize, b_idx: usize`
- Updated `insert_a`, `evaluate`, and `get_matches` to pass indices to weight function

### 3. `cross_bi_stream.rs` (solverforge-scoring)
- Updated `CrossBiConstraintBuilder::as_constraint` to adapt user's `Fn(&A, &B) -> Sc` closures to internal `Fn(&S, usize, usize) -> Sc`
- Added `Clone` bound on `EA` and `EB` extractors to allow adapting the weight closure

### 4. `factory_cross.rs` (solverforge-dynamic)
- Updated call to `make_cross_weight` to remove the `descriptor` parameter

### Test Results
- All 29 solverforge-dynamic tests pass
- All 104 solverforge-scoring unit tests pass  
- All 73 solverforge-scoring doctests pass
- Linting passes with no warnings


## Iteration 12 - 2026-02-04 22:17:36

Task completed. I ran the existing constraint tests to verify no regressions after all the weight function signature changes:

**Results:**
- All 8 constraint tests in `solverforge-dynamic` pass
- All 29 tests in `solverforge-dynamic` pass (including the 4-queens and 8-queens solver tests)
- All 104 unit tests in `solverforge-scoring` pass
- All 73 doctests in `solverforge-scoring` pass

This verifies that Phase 2 (Eliminate Weight Function Cloning) is complete with no regressions. The task has been marked complete in the PRD.


## Iteration 13 - 2026-02-04 22:20:48

Task completed. Here's a summary of the changes:

## Summary

I tracked the source class index in `ConstraintOp::ForEach` and `Join` by implementing a `param_to_class` mapping in the constraint builder.

### Changes Made:

**1. `crates/solverforge-py/src/constraint_builder.rs`:**
- Added documentation to `ConstraintOp` enum explaining that `ForEach` sets parameter A (index 0) and `Join` adds parameters B (index 1) and C (index 2)
- Updated `build_constraint()` to track `param_to_class: Vec<usize>` mapping parameter indices to class indices
- When `ForEach` is encountered, clears the mapping and sets param 0 to the class index
- When `Join` is encountered, adds the class index as the next parameter
- Updated `parse_expr()` signature to accept `&[usize]` instead of `Option<usize>`
- Updated `parse_simple_expr()` to use the parameter-to-class mapping for correct field lookup in the specific class (not searching all classes)

**2. `crates/solverforge-py/src/solver_manager.rs`:**
- Updated `build_constraint_internal()` to also track `param_to_class` mapping (same logic)
- Removed the now-unused `parse_expr_internal()` method

### Key Fix:
Before this change, when parsing expressions like `A.shift_id == B.shift_id`, the code would search ALL entity classes for the field name and return the first match. If `Employee` (class 0) has `shift_id` at field index 0 and `Shift` (class 1) has `shift_id` at field index 2, both would incorrectly get field index 0.

Now, `A.shift_id` correctly looks up in the class associated with parameter A, and `B.shift_id` looks up in the class associated with parameter B, returning the correct field indices for each class.

### Test Results:
- `cargo build -p solverforge-py` passes
- `cargo test -p solverforge-py` passes
- `cargo test -p solverforge-dynamic` passes (29 tests)
- `cargo clippy -p solverforge-py` reports no warnings


## Iteration 14 - 2026-02-04 22:22:37

I noticed the next task "Refactor parse_simple_expr to use param's class for field lookup" was also already completed as part of the same work. Looking at the code in `constraint_builder.rs` lines 270-291:

```rust
// Look up the class index for this parameter
let class_idx = param_to_class.get(param_idx).ok_or_else(|| {
    PyValueError::new_err(format!(
        "Parameter {} not yet defined (need ForEach or Join first)",
        param_str
    ))
})?;

// Get the class definition for this parameter's class
let class_def = descriptor.entity_classes.get(*class_idx).ok_or_else(|| {
    PyValueError::new_err(format!("Invalid class index: {}", class_idx))
})?;

// Look up field in the correct class (not all classes)
let field_idx = class_def.field_index(field_name).ok_or_else(|| {
    PyValueError::new_err(format!(
        "Unknown field '{}' in class '{}'",
        field_name, class_def.name
    ))
})?;
```

This shows that `parse_simple_expr` is already using the parameter's class for field lookup - it gets the class index from `param_to_class` and then looks up the field in that specific class's definition.

The task is complete. The `param_to_class` mapping was implemented as part of Iteration 13 along with the refactoring of `parse_simple_expr`. Both:

1. **`build_constraint()`** in `constraint_builder.rs` - tracks `param_to_class: Vec<usize>` mapping parameter indices to class indices
2. **`build_constraint_internal()`** in `solver_manager.rs` - same implementation 
3. **`parse_simple_expr()`** - uses `param_to_class` to look up the correct class for each parameter's field references

All tests pass and clippy reports no warnings.


## Iteration 15 - 2026-02-04 22:28:55

Task completed. Here's a summary of the changes:

## Summary

I added tests for cross-class constraints with same-named fields. Since `solverforge-py` is a pyo3 extension module with `extension-module` feature enabled, `cargo test` cannot run directly (pyo3 requires Python symbols at link time). Instead, I:

1. **Added tests in `crates/solverforge-dynamic/src/constraint/tests.rs`** (where they can actually run):
   - `test_cross_class_same_named_field_constraint`: Tests that constraints joining two classes with same-named fields at different indices (Employee.assigned_shift_id at index 2, Shift.assigned_shift_id at index 0) resolve the field indices correctly
   - `test_cross_class_same_named_field_with_filter`: More thorough test including filter expressions that also use same-named fields

2. **Added documentation in `crates/solverforge-py/src/constraint_builder.rs`**: Explained why tests are in solverforge-dynamic and what they verify

3. **Added `PartialEq` derive to `Expr` in `crates/solverforge-dynamic/src/expr.rs`**: Required for test assertions

### Test Results
- All 31 tests in solverforge-dynamic pass
- Both crates build successfully with no clippy warnings


## Iteration 16 - 2026-02-04 22:30:50

Task complete. I documented the key expression limitations in the `make_cross_key_a` and `make_cross_key_b` docstrings in `closures_cross.rs`. The documentation now includes:

1. **Supported Expression Types** - A comprehensive list of expressions that work correctly (Param(0), Field, Literal, arithmetic, comparisons, logic, conditionals, null checks)

2. **Unsupported Expression Types** - Clear documentation of what will fail at runtime:
   - `RefField` - Cannot dereference entity references because entities vector is empty
   - Fact lookups - Cannot access facts because facts vector is empty
   - `Param(n)` for n > 0 - Only the current entity (Param(0)) is available

3. **Design Rationale** - Explains why join keys have these limitations (stability, self-containment, determinism)

4. **Guidance** - Points users toward using filter expressions instead if they need full solution context

All 31 tests pass and clippy reports no warnings.


## Iteration 17 - 2026-02-04 22:34:40

Task completed. Here's a summary of what was implemented:

## Summary

Added runtime warnings when cross-join key expressions contain unsupported constructs (`RefField` or `Param(n)` where n > 0).

### Changes Made

**1. `closures_cross.rs`** - Added key expression limitation checking:
- New `check_key_expr_limitations(expr: &Expr) -> Vec<String>` function that recursively traverses an expression tree and collects warnings for:
  - `RefField` - requires entity/fact lookup which is unavailable in key context
  - `Param(n)` for n > 0 - only `Param(0)` (current entity) is available
- Updated `make_cross_key_a` to check the key expression and emit warnings to stderr before building the closure
- Updated `make_cross_key_b` with the same warning logic

**2. `constraint/tests.rs`** - Added comprehensive test:
- `test_key_expr_limitation_warnings` verifies:
  - Safe expressions (Field, Param(0), Literal, arithmetic) produce no warnings
  - `Param(1)`, `Param(2)` produce warnings
  - `RefField` produces warnings
  - Nested problematic expressions in arithmetic/conditionals are detected
  - Multiple issues produce multiple warnings

### Test Results
- All 32 tests pass (31 existing + 1 new)
- Clippy reports no warnings


## Iteration 18 - 2026-02-04 22:37:24

Task completed. Here's a summary:

## Summary

Completed the task "Consider passing full solution to key extractors for complex keys" by **documenting the design decision to NOT pass the full solution**.

### Design Decision

After analyzing the architecture, I determined that passing the full solution to key extractors would **break incremental constraint correctness**:

1. **Index invalidation problem**: The B-index (`b_by_key`) is built during `initialize()` and only updated when B entities are inserted/retracted. If a key depends on `RefField` (e.g., `employee.department.region_id`), the key value could change when the referenced entity is modified, but the B-index wouldn't be updated.

2. **Stale matches**: This would lead to incorrect constraint evaluations where the incremental score doesn't match a full recalculation.

3. **Correct alternative exists**: Users who need complex join logic can use the filter expression (which receives full solution context) instead of the key expression.

### Changes Made

Updated the docstrings in `closures_cross.rs` for both `make_cross_key_a` and `make_cross_key_b` to document:
- Why keys deliberately don't have full solution access
- The specific correctness issues this prevents (index invalidation, stale matches)
- The correct alternative: use simple keys and move complex logic to filter expressions

### Test Results
- All 32 solverforge-dynamic tests pass
- Clippy reports no warnings


## Iteration 19 - 2026-02-04 22:40:36

## Summary

I completed the task "Create DynamicMoveIterator struct implementing Iterator<Item=DynamicChangeMove>" in `crates/solverforge-dynamic/src/moves.rs`.

### Changes Made:

**Created `DynamicMoveIterator<'a>` struct** (lines 26-45):
- Holds a reference to the `DynamicSolution`
- Tracks iteration state: `class_idx`, `entity_idx`, `var_slot_idx`, `value_idx`
- Caches current variable info to avoid repeated lookups

**Implemented `DynamicMoveIterator::new()`** (lines 48-65):
- Initializes the iterator and advances to the first valid position

**Implemented `DynamicMoveIterator::advance_to_valid_position()`** (lines 67-127):
- Advances through the nested iteration (classes → entities → variables → values)
- Handles edge cases (empty classes, no planning variables, missing value ranges)

**Implemented `Iterator` trait** (lines 129-161):
- `next()` generates moves lazily one at a time
- Returns `None` when exhausted
- `size_hint()` provides bounds

**Added 4 comprehensive tests**:
- `test_dynamic_move_iterator`: Basic functionality with 2 entities, 4 values
- `test_dynamic_move_iterator_multiple_variables`: Tests entities with multiple planning variables
- `test_dynamic_move_iterator_empty_solution`: Tests edge case of no entities
- `test_dynamic_move_iterator_multiple_classes`: Tests iteration across multiple entity classes

### Test Results:
- All 36 solverforge-dynamic tests pass
- The iterator produces moves in the same order as the existing `generate_moves()` (before shuffling)
- Clippy warnings about unused code are expected - subsequent tasks will wire up the iterator


## Iteration 20 - 2026-02-04 22:43:07

Task completed. Here's a summary of what I did:

## Summary

Refactored `generate_moves` in `crates/solverforge-dynamic/src/moves.rs` to return a lazy iterator instead of a `Vec`.

### Changes Made:

1. **Changed `generate_moves` signature** (lines 291-302):
   - Old: `pub fn generate_moves(&self, solution: &DynamicSolution) -> Vec<DynamicChangeMove>`
   - New: `pub fn generate_moves<'a>(&self, solution: &'a DynamicSolution) -> DynamicMoveIterator<'a>`
   - Now returns a lazy `DynamicMoveIterator` that generates moves on-demand

2. **Added `generate_moves_shuffled` method** (lines 312-323):
   - For cases where randomized move order is needed (e.g., `FirstAcceptedForager`)
   - Collects the iterator and shuffles the result

3. **Updated `MoveSelector` trait impl** (lines 339-353):
   - `iter_moves` now uses `generate_moves_shuffled` to maintain randomized selection behavior
   - `size` now uses the lazy iterator with `.count()` to avoid allocating all moves

4. **Updated `test_generate_moves`** (line 491):
   - Added `.collect()` to convert iterator to Vec for length assertion

5. **Added `test_generate_moves_shuffled`** test:
   - Verifies the shuffled method works correctly
   - Ensures same number of moves as the lazy iterator

### Test Results:
- All 37 solverforge-dynamic tests pass
- Clippy reports no warnings


## Iteration 21 - 2026-02-04 22:46:19

Task completed. Here's a summary of the changes:

## Summary

Updated the `MoveSelector` trait implementation in `crates/solverforge-dynamic/src/moves.rs` to properly use the `DynamicMoveIterator`.

### Changes Made

**Updated `iter_moves` method documentation** (lines 331-360):
- Added comprehensive documentation explaining the design decision to use shuffled iteration
- Documented why randomization is critical: `FirstAcceptedForager` relies on randomized move order to escape local optima
- The implementation collects moves from the lazy `DynamicMoveIterator` via `generate_moves_shuffled()`, which:
  1. Creates a `DynamicMoveIterator` for lazy generation
  2. Collects all moves into a `Vec`
  3. Shuffles the moves for randomized selection
- Pointed users to `generate_moves()` for memory-constrained scenarios where deterministic order is acceptable

### Key Finding

During implementation, I discovered that removing the shuffle step caused the solver to fail the 4-queens and 8-queens tests. Without randomization, `FirstAcceptedForager` always evaluates moves in the same deterministic order and gets stuck in local optima. This validated the importance of maintaining shuffled iteration for actual solver usage.

### Test Results
- All 37 solverforge-dynamic tests pass (including the 4-queens and 8-queens solver tests)
- Clippy reports no warnings


## Iteration 22 - 2026-02-04 22:52:47

Task completed. Here's a summary:

## Summary

I benchmarked the lazy move generation iterator (`DynamicMoveIterator`) vs the old eager Vec approach. 

### Benchmark Results

**Full iteration (all moves consumed):**
| Scale | Lazy | Eager | Speedup |
|-------|------|-------|---------|
| 10 ent, 1K moves | 30µs | 29µs | ~equal |
| 50 ent, 5K moves | 122µs | 136µs | 1.12x |
| 100 ent, 10K moves | 244µs | 294µs | 1.21x |
| 500 ent, 50K moves | 1.23ms | 1.37ms | 1.12x |
| 1000 ent, 1M moves | 25.6ms | 47.8ms | **1.87x** |

**Partial iteration (first N from 50K moves):**
| Take N | Lazy | Eager | Speedup |
|--------|------|-------|---------|
| 10 | 413ns | 1.48ms | **3586x** |
| 100 | 2.6µs | 1.49ms | **570x** |
| 1000 | 25µs | 1.49ms | **60x** |
| 10000 | 246µs | 1.53ms | **6x** |

### Changes Made
1. Added an `#[ignore]`-marked benchmark test in `moves.rs` that can be run with:
   ```bash
   cargo test -p solverforge-dynamic --release bench_move_generation -- --nocapture --ignored
   ```

2. Documented the performance characteristics in the `DynamicMoveIterator` docstring, including the benchmark results and guidance on when lazy iteration is most beneficial.

3. All 37 tests pass with no clippy warnings.


## Iteration 23 - 2026-02-04 22:56:10

Task completed. Here's a summary of what was done:

## Summary

Created a benchmark test `bench_filter_lookup` in `crates/solverforge-dynamic/src/constraint/tests.rs` that compares the old O(n) linear search approach vs the new O(1) HashMap lookup for entity identification during filter evaluation.

### Benchmark Design

The benchmark measures two aspects:

1. **Raw Lookup Performance**: Directly compares `iter().position()` (old) vs `id_to_location.get()` (new) for entity ID lookups across all bi-constraint pairs

2. **Full Constraint Execution**: Measures actual constraint `initialize()` and `evaluate()` operations

### Results

```
| Entities | Pairs     | O(1) HashMap | O(n) Linear | Speedup   |
|----------|-----------|--------------|-------------|-----------|
| 100      | ~5K       | 161µs        | 217µs       | 1.3x      |
| 500      | ~125K     | 2.1ms        | 18.5ms      | 8.7x      |
| 1000     | ~500K     | 8.7ms        | 137ms       | 15.8x     |
| 2000     | ~2M       | 36ms         | 1058ms      | 29.6x     |
```

### How to Run

```bash
cargo test -p solverforge-dynamic --release bench_filter_lookup -- --nocapture --ignored
```

The benchmark is marked `#[ignore]` so it doesn't run during normal test execution, following the established pattern from `bench_move_generation` in `moves.rs`.


## Iteration 24 - 2026-02-04 22:59:36

Task completed. I added two integration tests with 1000+ entities to `crates/solverforge-dynamic/src/solve/tests.rs`:

1. **`test_large_scale_entity_assignments`** - A fast-running test that verifies:
   - All 1000 entities are correctly tracked in the solution
   - Entity IDs are correctly mapped via the `id_to_location` HashMap 
   - Constraint evaluation works correctly at scale
   - Incremental scoring produces valid results (4950 conflicts detected when 100 tasks on the same resource are assigned to the same slot)

2. **`test_solve_1000_entities`** - A longer-running `#[ignore]` test that verifies:
   - The solver can handle 1000 entities in a real solve
   - A feasible solution is found (all 1000 entities assigned unique positions)
   - The result is verified for correctness (no duplicate positions)

Both tests pass:
- `test_large_scale_entity_assignments` runs in 0.01s
- `test_solve_1000_entities` runs in ~28s and successfully assigns 1000 unique positions


## Iteration 25 - 2026-02-04 23:07:28

Task completed. Here's a summary of what was done:

## Summary

### Task: Test Python wrapper with employee scheduling problem

**Completed successfully.**

### Changes Made:

1. **Fixed API bug in `constraint_builder.rs`** - The `for_each` and `join` methods were expecting a `DescriptorRef` type that was never implemented. Changed them to accept `&Solver` directly, matching how the existing test files were written.

2. **Created `test_employee_scheduling.py`** - A comprehensive test file with 5 test cases:
   - `test_basic_employee_scheduling` - 5 employees, 10 shifts with no-overlap constraint
   - `test_cross_class_field_resolution` - Tests same-named fields across different entity classes (validates Phase 3 fixes)
   - `test_medium_scale_scheduling` - 20 employees, 100 shifts to verify O(1) lookup performance
   - `test_employee_shift_assignment_tracking` - Verifies entity assignments are correctly tracked
   - `test_soft_constraints` - Tests soft constraint handling

3. **Verified existing N-Queens tests pass** - Both 4-Queens and 8-Queens tests now work correctly.

### Test Results:
- All 5 employee scheduling Python tests pass
- All 38 solverforge-dynamic Rust tests pass
- All N-Queens Python tests pass
- No clippy warnings


## Iteration 26 - 2026-02-04 23:11:32

Task completed. I have:

1. **Added a comprehensive test `test_comprehensive_incremental_correctness`** in `crates/solverforge-dynamic/src/constraint/tests.rs` that verifies incremental scoring matches full recalculation after all the PRD performance changes.

The test covers:
- **Part 1: Bi Self-Join** with 10 insert operations and 3 retract operations, verifying after each that accumulated incremental score matches `evaluate()`
- **Part 2: Cross-Bi** with correct field resolution (Phase 3 fix verification), 10 shifts with various employee assignments, and 5 retracts
- **Part 3: Tri-constraint** with values 1-10 and 3 retracts from the end
- **Part 4: Multiple constraints on same solution** (row conflict + diagonal conflict), verifying both constraints stay in sync with their respective full evaluations

2. **Test results:**
   - All 39 solverforge-dynamic tests pass (3 are `#[ignore]` benchmarks)
   - All 73 solverforge-scoring tests pass
   - No clippy warnings

3. **Marked the task complete** in PRD.md

All 31/31 tasks in the PRD are now complete. The PRD for "SolverForge Dynamic Performance & Correctness Fixes" is fully implemented.

